PharoKernel shrinking reportError:FileWriteError: File /home/marichan/Development/minimal_image/latest_minimal/all_classes.txt write failed801 privSaveImageWithCleanup

	" Do not use this method for common image saving. This method is designated for saving the image during the shrinking process in headless images."
	
	20 timesRepeat: [
	  (Delay forMilliseconds: 50) wait.
	  Processor yield.
	  Smalltalk garbageCollect.
	].

	[
		self snapshot: true andQuit: true.
	] ifError: [:e |
		| rep |
		rep := FileStream forceNewFileNamed: 'PharoDebug.log'.
		rep nextPutAll: 'PharoKernel shrinking report'; cr.
		rep nextPutAll: 'Error:'; cr.
		rep nextPutAll: e asString; cr.
  		rep nextPutAll: thisContext stack size asString.
 	  	thisContext stack copy withIndexDo: [:stck :i |
			[ rep nextPutAll: i asString; space; nextPutAll: stck asString; cr] ifError: []].
		rep close. 
		Smalltalk exitFailure ] in SmalltalkImage>>privSaveImageWithCleanup2 BlockClosure>>cull:3 BlockClosure>>cull:cull:4 ifError: errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:ex |		errorHandlerBlock cull: ex description cull: ex receiver] in BlockClosure>>ifError:5 BlockClosure>>cull:6 Context>>evaluateSignal:7 Context>>handleSignal:8 Context>>handleSignal:9 Context>>handleSignal:10 Context>>handleSignal:11 Context>>handleSignal:12 FileWriteError(Exception)>>pass13 STCommandLineHandler>>handleError:reference:14 handleErrorsDuring: aBlock reference: aReference	aBlock		on: Error, OCSemanticWarning, OCSemanticError		do: [ :e | self handleError: e reference: aReference ] in STCommandLineHandler>>handleErrorsDuring:reference:15 BlockClosure>>cull:16 Context>>evaluateSignal:17 Context>>handleSignal:18 FileWriteError(Exception)>>signal19 FileWriteError(Exception)>>signal:20 StandardFileStream>>primWrite:from:startingAt:count:21 StandardFileStream>>nextPutAll:22 DoIt	'no source and no formatter available!' in DoIt	'no source and no formatter available!' in UndefinedObject>>DoIt23 OrderedCollection>>do:24 DoIt	'no source and no formatter available!' in UndefinedObject>>DoIt25 BlockClosure>>ensure:26 UndefinedObject>>DoIt27 OpalCompiler>>evaluate28 DoItChunk>>importFor:29 evaluate	" stripped down version of evaluateDeclarations"	| value |	self codeDeclarations do: [ :declaration |		requestor ifNotNil: [			requestor contents: declaration contents ].		value := declaration importFor: requestor ].	self flushChangesFile.		^value in CodeImporter>>evaluate30 OrderedCollection>>do:31 CodeImporter>>evaluate32 installSourceFile: aReference	"Install the source file given by aFileReference"	| codeImporter |	" parse the code given in the source file"	aReference readStreamDo: [ :stream |		self 			handleErrorsDuring: [				self skipShebangFrom: stream.				codeImporter := CodeImporter fileStream: stream.				codeImporter parseChunks ]			reference: aReference ].		"evaluate the declarations in a second step to allow for properly closing the source file stream"	self 		handleErrorsDuring: [ codeImporter evaluate ]		reference: aReference. in STCommandLineHandler>>installSourceFile:33 BlockClosure>>on:do:34 STCommandLineHandler>>handleErrorsDuring:reference:35 STCommandLineHandler>>installSourceFile:36 installSourceFiles	"Install the previously loaded source files"	sourceFiles ifNil: [ ^ self ].	[ sourceFiles do: [ :reference | 		self installSourceFile: reference ]	] ensure: [ sourceFiles := nil ].	 in installSourceFiles	"Install the previously loaded source files"	sourceFiles ifNil: [ ^ self ].	[ sourceFiles do: [ :reference | 		self installSourceFile: reference ]	] ensure: [ sourceFiles := nil ].	 in STCommandLineHandler>>installSourceFiles37 OrderedCollection>>do:38 installSourceFiles	"Install the previously loaded source files"	sourceFiles ifNil: [ ^ self ].	[ sourceFiles do: [ :reference | 		self installSourceFile: reference ]	] ensure: [ sourceFiles := nil ].	 in STCommandLineHandler>>installSourceFiles39 BlockClosure>>ensure:40 STCommandLineHandler>>installSourceFiles41 STCommandLineHandler>>activate42 STCommandLineHandler class(CommandLineHandler class)>>activateWith:43 activateSubCommand: aCommandLinehandler	[ aCommandLinehandler activateWith: commandLine ] on: Exit do: [ :exit |		^ self handleExit: exit for: aCommandLinehandler ].	"the return value of this method is used to check if the subcommand was successfull"	^ aCommandLinehandler in PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:44 BlockClosure>>on:do:45 PharoCommandLineHandler(BasicCommandLineHandler)>>activateSubCommand:46 PharoCommandLineHandler(BasicCommandLineHandler)>>handleSubcommand47 PharoCommandLineHandler(BasicCommandLineHandler)>>handleArgument:48 activate		[ self handleArgument: (self arguments 			ifEmpty: [ '' ] 			ifNotEmpty: [ :arguments| arguments first ])] 		on: Exit 		do: [ :exit | ^ self handleExit: exit ] in PharoCommandLineHandler(BasicCommandLineHandler)>>activate49 BlockClosure>>on:do:50 PharoCommandLineHandler(BasicCommandLineHandler)>>activate51 PharoCommandLineHandler>>activate52 PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:53 activateWith: aCommandLine		"Make sure that the PharoCommandLineHandler starts at the top of the stack in the main UI thread."	UIManager default defer:  [ 		super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:54 NonInteractiveUIManager(UIManager)>>defer:55 PharoCommandLineHandler class>>activateWith:56 activateSubCommand: aCommandLinehandler	[ aCommandLinehandler activateWith: commandLine ] on: Exit do: [ :exit |		^ self handleExit: exit for: aCommandLinehandler ].	"the return value of this method is used to check if the subcommand was successfull"	^ aCommandLinehandler in BasicCommandLineHandler>>activateSubCommand:57 BlockClosure>>on:do:58 BasicCommandLineHandler>>activateSubCommand:59 BasicCommandLineHandler>>handleSubcommand60 BasicCommandLineHandler>>handleArgument:61 activate		[ self handleArgument: (self arguments 			ifEmpty: [ '' ] 			ifNotEmpty: [ :arguments| arguments first ])] 		on: Exit 		do: [ :exit | ^ self handleExit: exit ] in BasicCommandLineHandler>>activate62 BlockClosure>>on:do:63 BasicCommandLineHandler>>activate64 startUp: isImageStarting	"only handle when lauching a new image"	isImageStarting ifFalse: [ ^ self ].	Smalltalk session 		addDeferredStartupAction: [ self new activate ] in BasicCommandLineHandler class>>startUp:65 BlockClosure>>cull:66 WorkingSession>>executeDeferredStartupActions:67 WorkingSession>>runStartup:68 WorkingSession>>start:69 SessionManager>>snapshot:andQuit:70 snapshot: save andQuit: quit	DefaultExecutionEnvironment beActiveDuring: 		 [^SessionManager default snapshot: save andQuit: quit] in SmalltalkImage>>snapshot:andQuit:71 CurrentExecutionEnvironment class>>activate:for:72 DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:73 DefaultExecutionEnvironment class>>beActiveDuring:74 SmalltalkImage>>snapshot:andQuit:75 privSaveImageWithCleanup

	" Do not use this method for common image saving. This method is designated for saving the image during the shrinking process in headless images."
	
	20 timesRepeat: [
	  (Delay forMilliseconds: 50) wait.
	  Processor yield.
	  Smalltalk garbageCollect.
	].

	[
		self snapshot: true andQuit: true.
	] ifError: [:e |
		| rep |
		rep := FileStream forceNewFileNamed: 'PharoDebug.log'.
		rep nextPutAll: 'PharoKernel shrinking report'; cr.
		rep nextPutAll: 'Error:'; cr.
		rep nextPutAll: e asString; cr.
  		rep nextPutAll: thisContext stack size asString.
 	  	thisContext stack copy withIndexDo: [:stck :i |
			[ rep nextPutAll: i asString; space; nextPutAll: stck asString; cr] ifError: []].
		rep close. 
		Smalltalk exitFailure ] in SmalltalkImage>>privSaveImageWithCleanup76 BlockClosure>>on:do:77 BlockClosure>>ifError:78 SmalltalkImage>>privSaveImageWithCleanup79 saveImageInNewContext	" This method is used for saving the Smalltalk image in a new process so the current process with all stack information may be forgotten.		Do not use this method for common image saving. This method is designated for saving the image during the shrinking process in headless images. "	[ self privSaveImageWithCleanup ] forkAt: 40. in SmalltalkImage>>saveImageInNewContext80 newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled.	IMPORTANT! Debug stepping this deep infrastructure may lock your Image  	If you are not sure what you are doing, close the debugger now."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			Processor terminateActive] asContext		priority: Processor activePriority in BlockClosure>>newProcess